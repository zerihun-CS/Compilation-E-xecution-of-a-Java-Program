# Compilation-Execution-of-a-Java-Program

Because Java is a platform-independent programming language, it does not provide one-step compilation.
Instead, it is executed in two steps: first through an OS-independent compiler, and then in a virtual machine(JVM) that is custom-built for each operating system.

![My Remote Image](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qQDHWG33fU2RQPNqd90unQ.jpeg)

## Compilation

A Java compiler is a computer software that is used to compile Java applications. It is platform agnostic.
It transforms source code (.java files) into bytecode (.class file).
In other words, bytecode is generated by the compiler (javac.exe) during the compilation process.

A bytecode is a binary code that the Java Virtual Machine (JVM) on the underlying operating system understands and interprets.
It is not comparable to machine code.


  ### Responsible tasks for Compiler
  
Apart from compiling a source program, Java compiler is responsible for the following tasks that are as follows:

	
     
  ፩) It converts source code into byte code with the help of Java Virtual Machine (JVM).
  
  ፪) Java compiler checks the syntaxial error (Syntax error).It also generates a list of all error messages when it finds errors 
  
  ፫) It also adds the additional code to your program if required also checks for assignments and reachability.
      
   #### N.B 
       -  A compiler does not detect logical errors in the program.

       -  It only creates an object code and does not execute the program
       
## Execution

JVM(Java Virtual Machine) acts as a run-time engine to run Java applications. JVM is the one that actually calls the main method present in a java code. JVM is a part of JRE(Java Runtime Environment).

Java applications are called WORA (Write Once Run Anywhere). This means a programmer can develop Java code on one system and can expect it to run on any other Java-enabled system without any adjustment. This is all possible because of JVM.
The compiler generates class files that are independent of the machine or the operating system, allowing them to operate on any system.
To run, the main class file (the class containing the function main) is handed to the JVM, which then travels through three major steps before executing the final machine code. 

![My Remote Image](https://www.guru99.com/images/java/052016_0614_WorkingofJa10.jpg)

#### JVM Class Loaders
Class loaders are in charge of dynamically loading Java classes into the JVM (Java Virtual Machine) during runtime.
They are also included in the JRE (Java Runtime Environment).
As a result of class loaders, the JVM does not need to know about the underlying files or file systems in order to run Java programs.


Furthermore, these Java classes are loaded into memory only when they are needed by an application.
This is when class loaders come in handy.
They are in charge of loading classes into memory. 



#### JVM bytecode verifier

After the class loader in the JVM loads the byte code of the.class file to the machine, the verifier checks the bytecode for integrity, which is known as verification.
The verifier does as much verification as feasible at the Linking so that the interpreter's intensive activity at run time may be avoided.
It improves the interpreter's performance. 

Some of the checks that verifier performs:

    - Uninitialized Variables
    - Access rules for private data and methods are not violated.
    - Method calls match the object Reference.
    - There are no operand stack overflows or underflows.
    - The arguments to all the Java Virtual Machine instructions are of valid types.
    - Ensuring that final classes are not subclassed and that final methods are not overridden
    - Checking that all field references and method references have valid names, valid classes, and a valid type descriptor.
    
#### Execution Engine

Execution Engine helps in executing the byte code by converting it into machine code and also interact with the memory area

 ##### Interpreter:
 It is responsible to read, interpret, and execute java program line by line. So if any method is called multiple times new interpretation required which is the main disadvantage of it.
 
##### JIT Compiler (Just In Time): 
The concept of the JIT compiler works only for a repeated method not for every method. To overcome the problem that the interpreter faced while interpreting the byte code, whenever it finds the repeated code, JIT Compiler compiles the entire bytecode and changes it to machine code. This machine code will be used directly for repeated method calls.

      

